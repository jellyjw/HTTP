## HTTP

우리는 HTTP 시대에 살고 있다. 모든 형태의 데이터(파일, 음성, 영상, Image, JSON, XML, HTML, TEXT 등) 를 전송할수 있으며, 서버간 데이터를 주고받을때에도 대부분 HTTP를 사용한다.

### HTTP 역사

- HTTP/0.9 - 1991년 : `GET` 메서드만 지원했으며, HTTP 헤더가 존재하지 않았다.
- HTTP/1.0 - 1996년 : 메서드와 헤더 추가
- **HTTP/1.1 - 1997년** : 가장 많이 사용되는 버전으로, 우리에게 가장 중요하다. 대부분의 기능이 포함되어 있다.
- HTTP/2.0 - 2015년 : 성능 개선
- HTTP/3.0 - 진행중 : TCP 대신 UDP 채택, 성능 개선

---

## HTTP 특징

### 클라이언트 서버 구조

예전에는 클라이언트와 서버가 분리되지 않았었다.

분리해서 서버에는 비즈니스 로직과 데이터를 넣고, 클라이언트에서는 UI와 사용성에 집중할수 있게 되었다.

→ 서버에서는 트래픽을 어떻게 처리할지 이런것들을 고민하고, 클라이언트에서는 UI와 사용성에 집중하여 관심사 분리

- Request - Response 구조
- 클라이언트가 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어 응답

### 무상태 프로토콜 - Stateless

- 서버가 클라이언트의 상태를 보존하지 않는 **무상태성**
- 장점 : 서버 확장성 높음(스케일 아웃)
- 단점 : 클라이언트가 추가 데이터 전송

무상태 프로토콜은, 서버에서 기존 요청의 정보, Context를 모르기 때문에 상태를 보존하지 않는다는 특징이 있다.

예를 들어 **”아까 먹었던 빵 2개 주세요”** 와 같은 요청이 불가하다는 것이다. 클라이언트에서 요청을 할 때에는, 어떤 빵을 몇개를 주문할 것인지를 서버에 함께 전송해야 원하는 응답을 받을수 있다.

→ 무상태성은 중간에 서버가 바뀌어도 응답을 보낼수 있기 때문에, 요청이 몰릴 경우 서버의 무한 증설(스케일 아웃)이 가능하다.

→ 만약 상태를 유지한다면, 중간에 서버ㅇ

### Stateless의 한계?

모든것을 무상태로 설계할 수 있는 것은 아니다. 예를 들어 로그인 상태 유지가 필요할 경우? 새로고침할때마다 로그인이 풀린다면 사용자는 큰 불편함을 겪을 것이다.

그래서 로그인이 필요 없는 단순한 랜딩페이지같은 경우에는 괜찮지만, 필요에 따라 브라우저 저장소인 쿠키나 세션등을 사용해서 상태를 유지하곤 한다.

→ 상태 유지는 필요한 경우에 최소한만 사용해야 한다.

## 비연결성

만약 서버와 클라이언트 간 연결이 계속 유지된다면? 서버는 여러 대의 클라이언트와 연결을 계속 유지하며 자원을 소모할 것이다.

HTTP는 기본이 연결을 유지하지 않는 모델로, 일반적으로 초 단위 이하의 빠른 속도로 응답이 가능하다.

수천, 수만명이 하나의 서비스를 이용하고 있더라도 요청을 동시에 보내지는 않기 때문에, 동시에 처리하는 요청은 수십개 이하로 매우 작기 때문에, 서버 자원을 매우 효율적으로 이용할 수 있다.

### 비연결성의 한계?

![image](https://github.com/jellyjw/HTTP/assets/104891203/ad4e0cfa-2b61-49bc-8f2d-9b917ceaa7b4)

- 연결할때마다 TCP/IP 연결을 새로 맺어야 함.
  - TCP는 3 way handshake 과정을 거치기 때문에 연결, 데이터 전송 등 신뢰할수 있는 반면 시간이 UDP보다 오래 걸리는 특징이 있었다.
  - 이렇게 TCP/IP 연결을 요청시마다 새로 맺으려면, 3 way handshake 시간이 추가된다.
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아닌 JS, CSS, 이미지, 폰트 등 수많은 자원이 함께 다운로드 된다.

![image](https://github.com/jellyjw/HTTP/assets/104891203/e3a55a8e-2b67-4edb-a96f-41d6f3fc3af9)

- 지금은 HTTP 지속 연결(Persistent Connections) 로 문제를 해결했다.
- HTTP/2, HTTP/3 에서 더 많은 최적화가 진행되었다.

### Stateless - 서버 개발자들이 가장 어려워 하는 업무

같은 시간에 딱 맞춰 발생하는 대용량 트래픽의 경우, 예를들어 19시에 치킨 할인쿠폰 증정 이벤트를 개최할 경우 19시에 수만명이 동시에 버튼을 클릭할 것이고, 요청이 몰리게 된다.

→ 이 때에는 동시에 요청이 몰릴것을 대비해 첫페이지는 로그인도 필요없는 정적 페이지를 띄운뒤, 이벤트 참여 버튼을 누르도록 유도해 최대한 트래픽을 분산시킬는 방법이 쓰이기도 한다.

## HTTP 메세지

앞서 메세지에 모든 데이터 형태 (HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON 등) 전송이 가능하다고 했다.

HTTP 메세지는 다음과 같이 이루어져 있다.

- 시작 라인(start-line)
- 헤더(header)
- 공백 라인(CRLF)
- 본문(body)

![image](https://github.com/jellyjw/HTTP/assets/104891203/83e0ba3c-54fb-448a-a30c-9f2754e1deaa)

### 시작 라인(Start-line)

시작 라인은 `request-line` 과 `status-line` 으로 이루어져 있다.

### request-line

- `method` SP(공백) `request-target` SP(공백) `HTTP-version` CRLF(엔터)
  - method - HTTP 메서드(GET - 조회) 로 서버가 수행해야 할 동작을 지정한다.
  - request-target - 요청 대상(`/search?q=hello`)으로, 절대경로로 입력한다.
  - HTTP version

### Status-line

- `HTTP-version` SP `status-code` SP `reason-phrase` CRLF(엔터)
  - HTTP 버전
  - HTTP 상태 코드 : 요청 성공, 실패를 나타낸다. (200 - 성공, 400 - client 오류, 500 - 서버 오류 등)
  - reason-phrase : 사람이 이해할 수 있는 짧은 상태 코드 설명 글

### 헤더(Header)

![image](https://github.com/jellyjw/HTTP/assets/104891203/9d0509a9-0e77-42fb-aa25-e1d63515ea89)

HTTP 전송에 필요한 모든 부가 정보를 담는다.

- 메시지 바디의 내용, 크기, 압축, 인증, 요청 정보, 서버정보, 캐시정보 등
- 필요시 임의의 헤더를 추가할수 있다.

### 공백 라인(CRLF, empty line)

헤더와 바디 간 공백은 무조건 한줄 들어가야 한다.

### Message Boby

- 실제 전송할 데이터를 담는다.
- `byte` 로 표현할 수 있는 모든 데이터를 전송 가능하다.

HTTP는 단순하며, 메시지도 매우 단순하다. 크게 성공하는 기술은, 단순하지만 확장이 가능한 기술이다.
