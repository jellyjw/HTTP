## 검증 헤더

캐시에 남아있는 수정일자와 서버에서 가지고 있는 자원의 수정일자를 비교해서, 수정이 되었을때만 body에 데이터를 담아서 보내주고 변경되지 않았을 경우 기존 서버 자원을 (캐시) 활용하여 헤더만 보내준다.

이렇게 함으로서 클라이언트에서 매번 같은 데이터를 다운받을 필요가 없게 되고, 속도나 용량측면에서도 이점을 얻게 된다.

- If-Modified-Since : 캐시와 서버의 데이터 마지막 수정일자가 같으면?
- If-Modified-Since : 캐시와 서버의 데이터 마지막 수정일자가 다르면?

### 단점?

- 1초 미만(0.x초) 단위는 캐시 조정 불가능(최대 초단위)
- 날짜 기반의 정해진 로직을 사용
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우

### ETag(Entity Tag)

- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
- 데이터 변경시, 이 이름을 바꾸어서 변경(Hash 다시 생성)
- 파일이 조금이라도 다르면 완전히 다른 해시값 생성됨.
- 단순하게 `ETag` 만 보내서 같으면 유지, 다르면 다시 다운로드

### If-None-Match

- 매치가 안되면, 즉 데이터가 변경되지 않았을 경우 **304 Not Modified**

→ 캐시 제어 로직을 **서버에서 완전히 관리** 함으로서, 클라이언트는 단순히 값을 서버에 제공하기만 한다.

## 캐시

만약 미국에 원(origin)서버가 있다고 하면, 매번 미국에 있는 서버에 요청을 할 경우 응답속도가 매우 느려지기 때문에 한국에 CDN같은 서버를 두고 CDN에서 다운로드 받도록 하는 방법을 많이 사용한다.

### Cache-Control

- public : 응답이 public 캐시에 저장되어도 됨
- **private : 해당 사용자만을 위한 응답, private 캐시에 저장(기본값)**
- s-maxage : 프록시 캐시에만 적용되는 max-age
- Age: 60 (HTTP 헤더) : 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)
- no-cache : 데이터는 캐시해도 되지만, 항상 **원 서버에 검증** 하고 사용
- no-store : 데이터에 민감한 정보가 있으므로 저장 X, 메모리에서 사용하고 최대한 빨리 삭제
- must-revalidate : 캐시 만료 후 최초 조회시 **원 서버에 검증**

### 캐시 무효화

**확실한 캐시 무효화 응답** 을 원할 경우? 즉, 웹브라우저 임의의 캐시조차도 막고싶을 경우

아래의 속성을 다 넣어줘야 한다.

- Cache-Control : no-cache, no-store, must-revalidate
- Pragma : no-cache (HTTP 1.0 하위 호환을 위해)
